{"version":3,"sources":["webpack:///webpack/bootstrap 4c1defc841c1bf89cf48","webpack:///./entry.js","webpack:///./constants.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,+BAA8B,YAAY;AAC1C,iCAAgC,wBAAwB;AACxD,0BAAyB,KAAK;AAC9B,0BAAyB,KAAK;AAC9B;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,0DAAyD,2DAA2D;AACpH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC,oBAAmB;AACnB,oBAAmB;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;;;AAGA;AACA;AACA,4BAA2B,QAAQ;AACnC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,iCAAgC,MAAM;;AAEtC;AACA;AACA,6BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA,6BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA,6BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA,6BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4c1defc841c1bf89cf48\n **/","const Constants = require('./constants');\n\nlet canvasBoard = document.getElementById(\"canvasBoard\");\nlet ctx = canvasBoard.getContext(\"2d\");\nlet canvasPower = document.getElementById(\"canvasPower\");\nlet ctxPower = canvasPower.getContext(\"2d\");\nlet canvasAim = document.getElementById(\"canvasAim\");\nlet ctxAim = canvasAim.getContext(\"2d\");\n\nlet obstNotBuilt = true;\nlet ballRadius = Constants.BALL_RADIUS;\nlet xPos = Constants.CANVAS_WIDTH/2;\nlet yPos = 15 + ballRadius;\nlet yHoleStart = Constants.CANVAS_HEIGHT - (3*Constants.HOLE_RADIUS);\nlet holeRadius = Constants.HOLE_RADIUS;\nlet strokes = 3;\nlet initialPower = 0;\nlet deltX = 0;\nlet deltY = 0;\nlet onSwing = false;\nlet mouseX, ballX, ballY, mouseY;\nlet masterRadians, masterPower;\nlet obstArray = [];\nlet level = 1;\nwindow.mouseX\nwindow.mouseY\n\ncanvasBoard.addEventListener(\"mousedown\", (function(e) {\n    filterClick(e);\n}));\n\nwindow.addEventListener(\"mousemove\", (function(e) {\n  updatePos(e);\n}));\n\nfunction filterClick(e) {\n  e.preventDefault();\n  if (((xPos - ballRadius) <= e.offsetX && e.offsetX <= (xPos + ballRadius)) && ((yPos - ballRadius) <= e.offsetY && e.offsetY <= (yPos + ballRadius))) {\n    // debugger//run the function to get speed and direction\n    ballX = window.mouseX;\n    ballY = window.mouseY;\n    onSwing = true;\n    swing(ballX, ballY)\n  }\n\n  console.log(\"miss\");\n};\n\nfunction strikeBall(xEnd, yEnd) {\n  console.log(\"striking ball\");\n  console.log(ballX);\n  console.log(ballY);\n  ctxPower.clearRect(0, 0, Constants.CP_WIDTH, Constants.CP_HEIGHT);\n  ctxAim.clearRect(0, 0, Constants.CA_WIDTH, Constants.CA_HEIGHT);\n  let xDif = (xEnd > ballX) ? (xEnd - ballX) : (ballX - xEnd);\n  let yDif = (yEnd > ballY) ? (yEnd - ballY) : (ballY - yEnd);\n  let pyth = (xDif * xDif) + (yDif * yDif);\n  let tot = Math.floor(Math.sqrt(pyth));\n\n\n  console.log(`masterPower= ${masterPower}`);\n  console.log(`masterRadians= ${Math.tan(masterRadians)}`);\n  // console.log(`yPos=${yPos}`);\n  // console.log(`yEnd=${yEnd}`);\n  // console.log(tot)\n  // console.log(xDif/yDif);\n\n  if (tot < 5) {\n    console.log(\"too small\")\n    return;\n  } else if (tot > 150) {\n    initialPower = 150;\n    strokes --;\n  } else {\n    initialPower = tot;\n    strokes --;\n  }\n\n  deltX = (Math.cos(masterRadians));\n  deltY = (Math.sin(masterRadians));\n\n  // console.log(tot)\n}\n\nfunction updatePos(e) {\n  window.mouseX = e.screenX;\n  window.mouseY = e.screenY;\n}\n\nfunction swing(xInit, yInit) {\n\n  this.addEventListener(\"mouseup\", (function() {\n    clearInterval(window.drawHitDetailInterval);\n    if (onSwing) {\n      strikeBall(window.mouseX, window.mouseY)\n      onSwing = false;\n    }\n    onSwing = false;\n  }));\n\n  window.drawHitDetailInterval = setInterval(function() {drawHitDetails(xInit, yInit, window.mouseX, window.mouseY)}, 5);\n};\n\nfunction buildObstacles (level) {\n  let i, x, y, dx, dy, distance;\n  let status = true;\n  i = 0;\n  while (i < (level + 3)) {\n    x = Math.floor(Math.random() * ((Constants.CANVAS_WIDTH - (Constants.OBS_RAD)) - (Constants.OBS_RAD)) + (Constants.OBS_RAD));\n    y = Math.floor(Math.random() * ((Constants.CANVAS_HEIGHT - 100) - 75) + 75);\n    for (let j = 0; j < obstArray.length; j++ ) {\n      status = true;\n      dx = x - obstArray[j][0];\n      dy = y - obstArray[j][1];\n      distance = Math.sqrt(dx * dx + dy * dy);\n      if (distance < (Constants.OBS_RAD * 2) + (Constants.BALL_RADIUS * 6)) {\n        status = false;\n        break;\n      }\n    }\n    if (status) {\n      obstArray.push([x, y]);\n      i++;\n    }\n\n  }\n  obstNotBuilt = false;\n}\n\nfunction draw() {\n  ctx.clearRect(0, 0, Constants.CANVAS_WIDTH, Constants.CANVAS_HEIGHT);\n  drawHole();\n  drawBall();\n  drawScore();\n  if (obstNotBuilt) {\n    buildObstacles(level);\n  }\n  drawObstacles();\n  if (initialPower > .4) {\n    xPos = xPos + (deltX * initialPower/10);\n    yPos = yPos + (deltY * initialPower/10);\n    initialPower *= .97;\n    checkStatus();\n  } else {\n    let holeX = xPos - (Constants.CANVAS_WIDTH/2);\n    let holeY = yPos - yHoleStart;\n    let distance = Math.sqrt((holeX * holeX) + (holeY * holeY));\n    if (distance < (Constants.HOLE_RADIUS - ballRadius/2)) {\n      alertWinner();\n    }\n\n    if (strokes === 0) {\n      endGame();\n    }\n  }\n\n}\n\nfunction drawObstacles () {\n  let x, y, i;\n  for (i = 0; i < obstArray.length; i++) {\n    x = obstArray[i][0];\n    y = obstArray[i][1];\n    ctx.beginPath();\n    ctx.arc(x, y, Constants.OBS_RAD, 0, Math.PI*2);\n    ctx.fillStyle = \"red\";\n    ctx.fill();\n    ctx.closePath\n  }\n}\n\nfunction drawBall() {\n  ctx.beginPath();\n  ctx.arc(xPos, yPos, ballRadius, 0, Math.PI*2);\n  ctx.fillStyle = \"white\";\n  ctx.fill();\n  ctx.closePath();\n  // setDirection();\n  // setInitialSpeed();\n};\n\nfunction checkStatus() {\n  if (xPos < 0) {\n    endGame();\n  }\n\n  if (xPos > Constants.CANVAS_WIDTH) {\n    endGame();\n  }\n\n  if (yPos > Constants.CANVAS_HEIGHT) {\n    endGame();\n  }\n\n  for (let i = 0; i < obstArray.length; i++ ) {\n    var circle1 = {radius: Constants.OBS_RAD, x: obstArray[i][0], y: obstArray[i][1]};\n    var circle2 = {radius: ballRadius, x: xPos, y: yPos};\n\n    var dx = circle1.x - circle2.x;\n    var dy = circle1.y - circle2.y;\n    var distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance < circle1.radius + circle2.radius) {\n        endGame();\n    }\n  }\n\n\n\n}\n\n\nfunction drawScore () {\n  ctx.font = \"20px Georgia\";\n  ctx.fillText(`strokes: ${strokes}`, Constants.CANVAS_WIDTH - 100, 30);\n}\n\n\nfunction drawHole() {\n  ctx.beginPath();\n  ctx.arc(Constants.CANVAS_WIDTH/2, yHoleStart, holeRadius, 0, Math.PI*2);\n  ctx.strokeStyle = \"black\";\n  ctx.lineWidth = 5;\n  ctx.stroke();\n}\n\nfunction drawHitDetails(xPos, yPos, xEnd, yEnd) {\n  // if (xEnd === undefined || yEnd === undefined) {\n  //   xEnd = xPos;\n  //   yEnd = yPos;\n  // }\n  ctxPower.clearRect(0, 0, Constants.CP_WIDTH, Constants.CP_HEIGHT);\n  ctxAim.clearRect(0, 0, Constants.CA_WIDTH, Constants.CA_HEIGHT);\n  let xDif = (xEnd > xPos) ? (xEnd - xPos) : (xPos - xEnd);\n  let yDif = (yEnd > yPos) ? (yEnd - yPos) : (yPos - yEnd);\n  let pyth = (xDif * xDif) + (yDif * yDif);\n  let tot = Math.floor(Math.sqrt(pyth));\n\n  masterPower = tot;\n\n  let startRad = getRad(xPos, yPos, xEnd, yEnd);\n  // console.log(startRad);\n\n  ctxPower.beginPath();\n  ctxPower.rect(0, 0, Constants.CP_WIDTH, (tot * 2));\n  ctxPower.fillStyle = \"red\";\n  ctxPower.fill();\n  ctxPower.closePath();\n\n  ctxAim.beginPath();\n  ctxAim.arc((Constants.CA_WIDTH/2), (Constants.CA_HEIGHT/2), Math.floor(Constants.CA_WIDTH/3), startRad - (Constants.ARC_CONST/2), (startRad + Constants.ARC_CONST));\n  ctxAim.lineWidth = 15;\n  ctxAim.strokeStyle = \"red\";\n  ctxAim.stroke();\n}\n\nfunction getRad(xPos, yPos, xEnd, yEnd) {\n  let slope, begin;\n  let xVal = xEnd - xPos;\n  let yVal = yPos - yEnd;\n  let xDif = Math.abs(xEnd - xPos);\n  let yDif = Math.abs(yEnd - yPos);\n  let slopeConst = (yDif/(xDif + .001))\n  // console.log(slopeConst)\n  if (slopeConst <= 1) {\n    slope = (1.570796 * slopeConst) / 2;\n    begin = 0;\n  } else {\n    slope = 1.570796 - (xDif/yDif);\n    begin = 1;\n  }\n  // console.log(`slope start=${slope}`);\n\n  if ((xVal > 0) && (yVal > 0)) {\n    slope = 3.141592 - slope;\n    // console.log(`slope=${slope}`)\n    // console.log(`1`)\n  }\n  if ((xVal <= 0) && (yVal >= 0)) {\n    slope = 0 + slope;\n    // console.log(`slope=${slope}`)\n    // console.log(`2`)\n  }\n  if ((xVal <= 0) && (yVal <= 0)) {\n    slope = 6.2831853 - slope;\n    // console.log(`slope=${slope}`)\n    // console.log(`3`)\n  }\n  if ((xVal > 0) && (yVal < 0)) {\n    slope = 3.141592 + slope;\n    // console.log(`slope=${slope}`)\n    // console.log(`4`)\n  }\n  masterRadians = slope;\n  return slope\n}\n\nfunction alertWinner() {\n  xPos = Constants.CANVAS_WIDTH/2;\n  yPos = 15 + ballRadius;\n  obstNotBuilt = true;\n  obstArray = [];\n  strokes = 3;\n  level ++;\n  window.alert(\"Congrats, you won.\")\n}\n\nfunction endGame() {\n  xPos = Constants.CANVAS_WIDTH/2;\n  yPos = 15 + ballRadius;\n  obstNotBuilt = true;\n  obstArray = [];\n  strokes = 3;\n  initialPower = 0;\n  window.alert(\"Sorry, try again.\")\n}\n\n// (Constants.ARC_CONST)/2\nsetInterval(draw, 10);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./entry.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = {\n  CANVAS_WIDTH: 600,\n  CANVAS_HEIGHT: 600,\n  BALL_RADIUS: 6,\n  HOLE_RADIUS: 16,\n  CP_WIDTH: 100,\n  CP_HEIGHT: 300,\n  CA_WIDTH: 150,\n  CA_HEIGHT: 150,\n  ARC_CONST: .5,\n  OBS_RAD: 30\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./constants.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}